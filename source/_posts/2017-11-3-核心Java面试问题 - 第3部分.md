---
layout: post
title: 核心Java面试问题 - 第3部分
categories: Java
tags:  java面试 
author: Marnner
excerpt: 核心Java面试问题 - 第3部分
grammar_cjkRuby: true
---

* content
{:toc}


# 核心Java面试问题 - 第3部分

在面试问题系列：第1部分和第2部分中，我们讨论了面试官大部分时间要问的一些重要问题。现在是时候进行讨论了。在这篇文章中，我将在下面给出问题列表。



## 深拷贝和浅拷贝？

一个克隆是原始的精确副本。在Java中，它基本上意味着能够创建一个与原始对象具有相似状态的对象。 clone（）方法提供了这个功能。

浅拷贝重复尽可能少。默认情况下，java克隆是浅拷贝或者“逐个字段拷贝”，也就是说，Object类不知道clone（）方法将被调用的类的结构。所以，JVM在被要求克隆的时候，要做以下的事情：

1）如果类只有原始数据类型成员，那么将创建对象的全新副本，并返回对新副本的引用。

2）如果类包含任何类类型的成员，那么只有对这些成员的对象引用被复制，因此原始对象中的成员引用以及克隆对象引用同一个对象。

深拷贝复制一切。集合的深层副本是两个集合，其中原始集合中的所有元素都是重复的。在这里，我们想要一个独立于原始的克隆，并且克隆的变化不应该影响原始的。

深度克隆需要满足以下规则。

- 不需要单独复制原始数据。
- 原始类中的所有成员类都应该支持克隆，而在上下文中的克隆方法应该调用所有成员类上的super. clone()。
- 如果任何成员类不支持克隆，那么在克隆方法中，必须创建该成员类的新实例，并将其所有属性逐一复制到新的成员类对象。这个新的成员类对象将被设置在克隆对象中。

## 什么是同步？对象级别锁定和类级别锁定？

同步是指多线程。一个同步的代码块一次只能执行一个线程。Java支持执行多个线程。这可能导致两个或多个线程访问相同的字段或对象。同步是一个过程，它使所有并发线程处于同步状态。同步避免了由于共享内存视图不一致导致的内存一致性错误。当一个方法被声明为同步时;如果另一个线程正在执行同步的方法，线程将为该方法的对象保存监视器，您的线程被阻塞，直到该线程释放监视器。



使用synchronized关键字实现java的同步。在定义的方法或块中，可以在类中使用synchronized关键字。在类定义中，关键字不能与变量或属性一起使用



当您想要同步非静态方法或非静态代码块时，对象级别锁定是一种机制，这样只有一个线程能够在类的给定实例上执行代码块。应该始终这样做，以使实例级数据线程安全。





类级别锁定防止多个线程在运行时的所有可用实例中同步地进入同步块。这意味着，如果在运行时有100个DemoClass实例，那么只有一个线程能够在任何一个实例中执行demoMethod()，而其他所有实例将被锁定在其他线程上。应该始终这样做，使静态数据线程安全。



## 你可以给这个引用变量分配null吗？



不。你不能。在java中，赋值语句的左侧必须是一个变量。“this”是代表当前实例的特殊关键字。这不是任何变量。



同样，空值不能被分配给“super”或任何这样的关键字。



## 如何覆盖equals和hashCode（）方法？

在Java对象的父类中的Object类中定义了hashCode（）和equals（）方法。由于这个原因，所有java对象都继承这些方法的默认实现。

hashCode()方法用于获得给定对象的唯一整数。这个整数用于确定bucket位置，当该对象需要存储在诸如数据结构之类的HashTable中。默认情况下，对象的hashCode()方法返回和存储对象的内存地址的整数表示。



如名称所示，equals（）方法用于简单地验证两个对象的相等性。默认实现只需检查两个对象的对象引用来验证它们的相等性。

以下是覆盖这些功能时要记住的重点。

- 总是使用对象的相同属性来生成hashCode()和equals()。在我们的案例中，我们使用了员工id。
- equals（）必须一致（如果对象没有被修改，那么它必须保持返回相同的值）。
- 每当a.equals（b），那么a.hashCode（）必须与b.hashCode（）相同。
- 如果你重写一个，那么你应该重写另一个